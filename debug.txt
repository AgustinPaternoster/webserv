void handle_cgi_read(std::vector<struct pollfd> &poll_fds, CgiTask &cgiJobs, size_t &i)
{
    int current_fd = poll_fds[i].fd;
    short revents = poll_fds[i].revents; // Miramos qué eventos ocurrieron
    t_cgi_job &cgi_task = cgiJobs.getCgiTask(current_fd);
    
    // 1. GESTIÓN DE ERRORES DEL PIPE (Sin usar errno)
    if (revents & POLLERR) {
        handle_critical_error(poll_fds, cgiJobs, i, cgi_task);
        return;
    }

    // 2. LECTURA DE DATOS
    if (revents & POLLIN) {
        char buffer[4096];
        ssize_t bytes_read = read(current_fd, buffer, sizeof(buffer));
        
        if (bytes_read > 0) {
            cgi_task.cgi_output_buffer.append(buffer, bytes_read);
            // Lógica de header_parsed...
        }
        // Si read devuelve 0 con POLLIN, es que se cerró justo ahora
        else if (bytes_read == 0) {
            handle_cgi_finish(poll_fds, cgiJobs, i, cgi_task);
            return;
        }
    }

    // 3. CIERRE DEL LADO DEL HIJO (Hang up)
    // A veces POLLHUP llega solo o junto a POLLIN
    if (revents & POLLHUP && !(revents & POLLIN)) {
        handle_cgi_finish(poll_fds, cgiJobs, i, cgi_task);
    }
}
